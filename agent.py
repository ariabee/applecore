# Agent class for game character. 
# Testing out python logic for mapping instructions to functions.

from knowledge import Knowledge
from transcript import Transcript

# Action functions
# def yes(instruct):
# 	# validate previous instruction mapped to movement

# 	# feedback
# 	return("Yay!")

# ACTIONS = [move(instruct), left(instruct), right(instruct), yes(instruct), no(instruct)]

def move(instruct):

	response = instruct + ": *agent is moving*"
	return(response)



# Game agent
class Agent:
	'''
	Create an agent character for the game.
	param: knowledge, a dictionary mapping of strings (commands) to enumerated actions (functions)
	'''
	def __init__(self):
		self.name = "Young Apple"
		self.position = (20,20) # testing position
		self.knowledge = Knowledge(self)
		self.transcript = Transcript()
		self.current_actions = [] # working memory

	# def process(raw_instruction):
	# 	instruction = raw_instruction.split() # nvm bc want any string combo

	def give_name(self, new_name):
		self.name = new_name
		mapped_meaning = self.knowledge.lexicon()["you"]
		self.knowledge.add_to_lexicon(new_name, mapped_meaning)

	def store_parsed_actions(self, parsed_actions):
		self.current_actions = parsed_actions

	def interpret(self, instruction):
		"""
		The Agent processes the instruction into 
		1) words "it understands" / that are retrievable in the knowledge base
		2) a list of actions to carry out

		param: instruction, the input string from the user

		return: composition, the recognized string of words
		return: actions, the list of corresponding actions 
		"""

		composition = ""
		actions = []
		unknowns = ""

		instruction_split = instruction.split() # split sentence into list of words
		lexicon = self.knowledge.lexicon()
		learned = self.knowledge.learned()
		# instruction_edited = instruction

		# # First check for learned phrases
		# for phrase in learned:
		# 	if phrase in instruction:
		# 		composition += (phrase + " ")
		# 		actions.append(learned[phrase])

		# 		# If found, remove phrase from instruction
		# 		instruction_edited = instruction_edited.replace(phrase, " ")
		
		# instruction_split = instruction_edited.split()

		# Check for movement words in the instruction that the agent also recognizes
		for word in instruction_split:
			if word in lexicon:
				composition += (word + " ")
				actions.append(lexicon[word])

		self.store_parsed_actions(actions)

		return(composition, actions)
		#return(composition, self.try_actions(actions))

	def try_actions(self, parsed_actions):
		"""
		Execute the retrieved action functions.
		"""
		responses = []

		for actions in parsed_actions:
			for action in actions:
				action_response = self.knowledge.actions[action]() # do the action, get the response
				responses.append(action_response) # todo: update responses to be specific to user's words 
												# (through a function parameter or through function itself)

		return(responses)

	def attempt(self, instructions):
		"""
		Make an attempt to interpret and parse actions from the given input.

		param: instruction, the input string from the user

		return: compositon, the composed and recognized string of words
		return: responses, the responses generated by doing the actions
		"""
		# Interpret the instructions
		composition, parsed_actions = self.interpret(instructions)

		# Save the parsed actions to working memory
		self.current_actions = parsed_actions

		# Try the actions and collect the responses
		responses = self.try_actions(parsed_actions)

		return(composition, responses)

		












